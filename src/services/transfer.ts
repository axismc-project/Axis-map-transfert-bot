import { PterodactylService } from './pterodactyl.js';
import { SftpService } from './sftp.js';
import { ProgressTracker } from '../utils/progress.js';
import { Logger } from '../utils/logger.js';
import { ServerConfig } from '../types/index.js';
import fs from 'fs-extra';
import * as path from 'path';

interface TransferStatusUpdate {
  phase: 'download' | 'upload';
  percentage: number;
  speed: number;
  eta: number;
}

export class TransferService {
  private srv1Ptero: PterodactylService;
  private srv2Ptero: PterodactylService;
  private srv1Sftp: SftpService;
  private srv2Sftp: SftpService;
  private tracker: ProgressTracker;
  private tempCachePath: string;
  private statusUpdateCallback?: (status: TransferStatusUpdate) => void;
  private archiveName: string = '';

  constructor(
    srv1Config: ServerConfig,
    srv2Config: ServerConfig
  ) {
    this.srv1Ptero = new PterodactylService(srv1Config);
    this.srv2Ptero = new PterodactylService(srv2Config);
    this.srv1Sftp = new SftpService(srv1Config);
    this.srv2Sftp = new SftpService(srv2Config);
    this.tracker = new ProgressTracker();
    this.tempCachePath = process.env.TEMP_CACHE_PATH || '/tmp/playerdata_backup';
  }

  setStatusUpdateCallback(callback: (status: TransferStatusUpdate) => void): void {
    this.statusUpdateCallback = callback;
  }

  async executeTransfer(progressCallback?: (tracker: ProgressTracker) => void): Promise<void> {
    let srv1Connected = false;
    let srv2Connected = false;

    try {
      Logger.info('üöÄ D√©but du transfert de map Build ‚Üí Staging v3.2 (Auto-refresh + Auto-restart)');

      // √âtape 1: Pr√©paration
      await this.executeStep(0, 'Pr√©paration du transfert', async () => {
        this.tracker.updateStep(0, 'running', 'Initialisation...', 50);
        progressCallback?.(this.tracker);

        await new Promise(resolve => setTimeout(resolve, 2000));

        this.tracker.updateStep(0, 'running', 'Pr√©paration termin√©e', 100);
        progressCallback?.(this.tracker);
      });

      // √âtape 2: Arr√™t des serveurs
      await this.executeStep(1, 'Arr√™t srv1 & srv2', async () => {
        this.tracker.updateStep(1, 'running', 'Arr√™t du serveur Build...', 25);
        progressCallback?.(this.tracker);
        await this.srv1Ptero.setPowerState('stop');

        this.tracker.updateStep(1, 'running', 'Arr√™t du serveur Staging...', 50);
        progressCallback?.(this.tracker);
        await this.srv2Ptero.setPowerState('stop');

        this.tracker.updateStep(1, 'running', 'Attente arr√™t complet (45s)...', 75);
        progressCallback?.(this.tracker);
        await Promise.all([
          this.srv1Ptero.waitForServerState('offline', 45000),
          this.srv2Ptero.waitForServerState('offline', 45000)
        ]);
      });

      // Connexions SFTP
      this.tracker.updateStep(2, 'running', 'Connexion SFTP aux serveurs...', 0);
      progressCallback?.(this.tracker);
      
      await this.srv1Sftp.connect();
      srv1Connected = true;
      Logger.success('‚úÖ Connexion SFTP srv1 √©tablie');
      
      await this.srv2Sftp.connect();
      srv2Connected = true;
      Logger.success('‚úÖ Connexion SFTP srv2 √©tablie');

      // √âtape 3: Compression de la map srv1
      await this.executeStep(2, 'Compression /world srv1', async () => {
        this.tracker.updateStep(2, 'running', 'Compression en cours...', 50);
        progressCallback?.(this.tracker);
        this.archiveName = await this.srv1Ptero.compressFolder('world');
        Logger.info(`üì¶ Archive cr√©√©e: ${this.archiveName}`);
      });

      // √âtape 4: Sauvegarde playerdata srv2
      await this.executeStep(3, 'Sauvegarde playerdata srv2', async () => {
        await this.backupPlayerData(progressCallback);
      });

      // √âtape 5: Transfert SFTP srv1 ‚Üí srv2
      await this.executeStep(4, 'Transfert SFTP srv1 ‚Üí srv2', async () => {
        await this.srv2Sftp.transferFileDirect(
          this.srv1Sftp,
          this.archiveName,
          this.archiveName,
          ({ phase, data }) => {
            const phaseText = phase === 'download' ? 'T√©l√©chargement' : 'Upload';
            const speedText = data.speed > 0 ? ` - ${(data.speed / (1024 * 1024)).toFixed(2)} MB/s` : '';
            const etaText = data.eta !== Infinity ? ` - ETA: ${Math.ceil(data.eta)}s` : '';

            this.tracker.updateStep(
              4,
              'running',
              `${phaseText}: ${data.percentage}%${speedText}${etaText}`,
              data.percentage
            );
            progressCallback?.(this.tracker);

            // Callback pour la mise √† jour du statut Discord
            if (this.statusUpdateCallback) {
              this.statusUpdateCallback({
                phase,
                percentage: data.percentage,
                speed: data.speed / (1024 * 1024), // Convert to MB/s
                eta: data.eta
              });
            }
          }
        );
        Logger.success('‚úÖ Transfert SFTP termin√©');
      });

      // üîÑ NOUVEAU : Auto-restart du serveur 1 d√®s que le transfert est termin√©
      await this.executeStep(5, 'Auto-restart serveur Build', async () => {
        this.tracker.updateStep(5, 'running', 'Red√©marrage automatique du serveur Build...', 50);
        progressCallback?.(this.tracker);
        
        try {
          await this.srv1Ptero.setPowerState('start');
          Logger.success('‚úÖ Serveur Build red√©marr√© automatiquement apr√®s transfert');
          
          this.tracker.updateStep(5, 'running', 'Serveur Build red√©marr√©', 100);
          progressCallback?.(this.tracker);
        } catch (error) {
          Logger.warning('‚ö†Ô∏è Impossible de red√©marrer automatiquement le serveur Build', error);
          this.tracker.updateStep(5, 'running', 'Red√©marrage manuel requis pour srv1', 100);
          progressCallback?.(this.tracker);
        }
      });

      // √âtape 6: Suppression ancien /world srv2 (ancienne √©tape 5)
      await this.executeStep(6, 'Suppression ancien /world srv2', async () => {
        this.tracker.updateStep(6, 'running', 'Suppression de l\'ancienne map...', 50);
        progressCallback?.(this.tracker);
        
        try {
          await this.srv2Ptero.deleteFolder('world');
          Logger.success('‚úÖ Ancienne map supprim√©e');
        } catch (error) {
          Logger.warning('‚ö†Ô∏è Aucune ancienne map √† supprimer');
        }
      });

      // √âtape 7: D√©compression nouvelle map (avec polling √©tendu 2h) (ancienne √©tape 6)
      await this.executeStep(7, 'D√©compression nouvelle map', async () => {
        this.tracker.updateStep(7, 'running', 'Extraction en cours (polling 5min, timeout 2h)...', 10);
        progressCallback?.(this.tracker);
        
        Logger.info('‚è∞ D√©marrage extraction avec timeout √©tendu (2h max, v√©rification toutes les 5min)');
        
        // M√©thode avec polling √©tendu modifi√©e
        await this.srv2Ptero.extractArchive(this.archiveName, '/');
        
        this.tracker.updateStep(7, 'running', 'Extraction termin√©e', 100);
        progressCallback?.(this.tracker);
        Logger.success('‚úÖ Nouvelle map extraite (polling √©tendu)');
      });

      // √âtape 8: Nettoyage des fichiers (ancienne √©tape 7)
      await this.executeStep(8, 'Nettoyage fichiers', async () => {
        // Suppression de l'archive sur les deux serveurs
        this.tracker.updateStep(8, 'running', 'Suppression archive srv1...', 20);
        progressCallback?.(this.tracker);
        
        try {
          await this.srv1Ptero.deleteFile(this.archiveName);
          Logger.success('‚úÖ Archive supprim√©e sur srv1');
        } catch (error) {
          Logger.warning('‚ö†Ô∏è Archive non trouv√©e sur srv1');
        }

        this.tracker.updateStep(8, 'running', 'Suppression archive srv2...', 40);
        progressCallback?.(this.tracker);
        
        try {
          await this.srv2Ptero.deleteFile(this.archiveName);
          Logger.success('‚úÖ Archive supprim√©e sur srv2');
        } catch (error) {
          Logger.warning('‚ö†Ô∏è Archive non trouv√©e sur srv2');
        }

        // Suppression des fichiers ind√©sirables dans world
        this.tracker.updateStep(8, 'running', 'Nettoyage /world/stats...', 60);
        progressCallback?.(this.tracker);
        
        try {
          await this.srv2Ptero.deleteFolder('world/stats');
          Logger.success('‚úÖ Dossier stats supprim√©');
        } catch (error) {
          Logger.warning('‚ö†Ô∏è Dossier stats non trouv√©');
        }

        this.tracker.updateStep(8, 'running', 'Suppression icon.png...', 80);
        progressCallback?.(this.tracker);
        
        try {
          await this.srv2Ptero.deleteFile('world/icon.png');
          Logger.success('‚úÖ Fichier icon.png supprim√©');
        } catch (error) {
          Logger.warning('‚ö†Ô∏è Fichier icon.png non trouv√©');
        }
      });

      // √âtape 9: Restauration playerdata srv2 (ancienne √©tape 8)
      await this.executeStep(9, 'Restauration playerdata srv2', async () => {
        await this.restorePlayerData(progressCallback);
      });

      // √âtape 10: Red√©marrage serveur Staging seulement (ancienne √©tape 9 modifi√©e)
      await this.executeStep(10, 'Red√©marrage serveur Staging', async () => {
        // Le serveur Build est d√©j√† red√©marr√© √† l'√©tape 5
        this.tracker.updateStep(10, 'running', 'D√©marrage du serveur Staging...', 50);
        progressCallback?.(this.tracker);
        await this.srv2Ptero.setPowerState('start');
        Logger.success('‚úÖ Serveur Staging red√©marr√©');

        this.tracker.updateStep(10, 'running', 'Attente d√©marrage complet Staging (45s)...', 75);
        progressCallback?.(this.tracker);
        await this.srv2Ptero.waitForServerState('running', 45000);
        Logger.success('‚úÖ Serveur Staging d√©marr√©');
        
        this.tracker.updateStep(10, 'running', 'Les deux serveurs sont op√©rationnels', 100);
        progressCallback?.(this.tracker);
      });

      Logger.success('üéâ Transfert de map v3.2 termin√© avec succ√®s (auto-refresh + auto-restart) !');
      Logger.info('üîÑ Serveur Build : Red√©marr√© automatiquement apr√®s transfert');
      Logger.info('üéØ Serveur Staging : Red√©marr√© avec la nouvelle map');

    } catch (error: any) {
      Logger.error('‚ùå Erreur lors du transfert v3.2', error);

      // Marquer l'√©tape actuelle comme erreur
      const currentStep = this.tracker.getCurrentStep();
      if (currentStep >= 0) {
        this.tracker.updateStep(currentStep, 'error', `Erreur: ${error.message}`, 0);
        progressCallback?.(this.tracker);
      }

      // Tentative de rollback complet
      await this.handleRollback();
      throw error;

    } finally {
      // Nettoyage des connexions
      await this.cleanup(srv1Connected, srv2Connected);
      
      // R√©initialiser le callback de statut
      this.statusUpdateCallback = undefined;
    }
  }

  private async executeStep(stepIndex: number, stepName: string, operation: () => Promise<void>): Promise<void> {
    try {
      Logger.info(`üîÑ √âtape ${stepIndex + 1}/11: ${stepName}`);
      this.tracker.updateStep(stepIndex, 'running', 'En cours...', 0);

      const startTime = Date.now();
      await operation();
      const duration = Date.now() - startTime;

      this.tracker.updateStep(stepIndex, 'completed', `Termin√© (${Math.round(duration/1000)}s)`, 100);
      Logger.success(`‚úÖ √âtape ${stepIndex + 1}/11 termin√©e en ${Math.round(duration/1000)}s: ${stepName}`);
    } catch (error) {
      this.tracker.updateStep(stepIndex, 'error', `Erreur: ${error instanceof Error ? error.message : 'Erreur inconnue'}`, 0);
      throw error;
    }
  }

  private async backupPlayerData(progressCallback?: (tracker: ProgressTracker) => void): Promise<void> {
    try {
      this.tracker.updateStep(3, 'running', 'V√©rification playerdata...', 25);
      progressCallback?.(this.tracker);

      // V√©rifier si le dossier playerdata existe
      const playerdataExists = await this.srv2Sftp.fileExists('world/playerdata');

      if (playerdataExists) {
        this.tracker.updateStep(3, 'running', 'Sauvegarde playerdata...', 50);
        progressCallback?.(this.tracker);

        // Cr√©er le dossier de cache temporaire
        await fs.ensureDir(this.tempCachePath);
        Logger.info(`üìÅ Cache temporaire cr√©√©: ${this.tempCachePath}`);

        // T√©l√©charger le dossier playerdata
        await this.srv2Sftp.downloadFolder(
          'world/playerdata',
          path.join(this.tempCachePath, 'playerdata')
        );

        this.tracker.updateStep(3, 'running', 'Sauvegarde termin√©e', 100);
        progressCallback?.(this.tracker);

        Logger.success('‚úÖ PlayerData sauvegard√© dans le cache temporaire');
      } else {
        this.tracker.updateStep(3, 'running', 'Cr√©ation dossier playerdata vide...', 75);
        progressCallback?.(this.tracker);
        
        Logger.warning('‚ö†Ô∏è Aucun dossier playerdata trouv√© sur srv2, cr√©ation d\'un dossier vide');
        await fs.ensureDir(path.join(this.tempCachePath, 'playerdata'));
       
       this.tracker.updateStep(3, 'running', 'Dossier vide cr√©√©', 100);
       progressCallback?.(this.tracker);
     }
   } catch (error: any) {
     Logger.error('‚ùå Erreur lors de la sauvegarde playerdata', error);
     throw new Error(`Impossible de sauvegarder playerdata: ${error.message}`);
   }
 }

 private async restorePlayerData(progressCallback?: (tracker: ProgressTracker) => void): Promise<void> {
   try {
     this.tracker.updateStep(9, 'running', 'Suppression playerdata srv1...', 25);
     progressCallback?.(this.tracker);

     // Supprimer le playerdata de la map srv1 (nouvelle map)
     try {
       await this.srv2Ptero.deleteFolder('world/playerdata');
       Logger.success('‚úÖ PlayerData de srv1 supprim√©');
     } catch (error) {
       Logger.warning('‚ö†Ô∏è Aucun playerdata srv1 √† supprimer');
     }

     this.tracker.updateStep(9, 'running', 'Restauration playerdata srv2...', 50);
     progressCallback?.(this.tracker);

     // V√©rifier si nous avons une sauvegarde
     const backupPath = path.join(this.tempCachePath, 'playerdata');
     const backupExists = await fs.pathExists(backupPath);

     if (backupExists) {
       // Restaurer le playerdata sauvegard√©
       await this.srv2Sftp.uploadFolder(
         backupPath,
         'world/playerdata'
       );

       this.tracker.updateStep(9, 'running', 'Restauration termin√©e', 100);
       progressCallback?.(this.tracker);

       Logger.success('‚úÖ PlayerData de srv2 restaur√©');
     } else {
       this.tracker.updateStep(9, 'running', 'Aucune sauvegarde trouv√©e', 90);
       progressCallback?.(this.tracker);
       Logger.warning('‚ö†Ô∏è Aucune sauvegarde playerdata trouv√©e');
     }

     // Nettoyer le cache temporaire
     this.tracker.updateStep(9, 'running', 'Nettoyage cache temporaire...', 95);
     progressCallback?.(this.tracker);
     
     try {
       await fs.remove(this.tempCachePath);
       Logger.success('‚úÖ Cache temporaire nettoy√©');
     } catch (cleanupError) {
       Logger.warning('‚ö†Ô∏è Impossible de nettoyer le cache temporaire', cleanupError);
     }

   } catch (error: any) {
     Logger.error('‚ùå Erreur lors de la restauration playerdata', error);
     throw new Error(`Impossible de restaurer playerdata: ${error.message}`);
   }
 }

 private async handleRollback(): Promise<void> {
   try {
     Logger.warning('üîÑ D√©but du rollback complet v3.2...');

     // 1. Nettoyer le cache temporaire
     try {
       if (await fs.pathExists(this.tempCachePath)) {
         await fs.remove(this.tempCachePath);
         Logger.success('‚úÖ Cache temporaire supprim√© lors du rollback');
       }
     } catch (cleanupError) {
       Logger.error('‚ùå Erreur lors du nettoyage du cache temporaire', cleanupError);
     }

     // 2. Supprimer le fichier compress√© sur srv1 si il existe
     if (this.archiveName) {
       try {
         await this.srv1Ptero.deleteFile(this.archiveName);
         Logger.success(`‚úÖ Archive ${this.archiveName} supprim√©e sur srv1 lors du rollback`);
       } catch (archiveError) {
         Logger.warning(`‚ö†Ô∏è Impossible de supprimer l'archive ${this.archiveName} sur srv1`, archiveError);
       }

       // 3. Supprimer le fichier compress√© sur srv2 si il existe
       try {
         await this.srv2Ptero.deleteFile(this.archiveName);
         Logger.success(`‚úÖ Archive ${this.archiveName} supprim√©e sur srv2 lors du rollback`);
       } catch (archiveError) {
         Logger.warning(`‚ö†Ô∏è Impossible de supprimer l'archive ${this.archiveName} sur srv2`, archiveError);
       }
     }

     // 4. Red√©marrer les serveurs s'ils sont arr√™t√©s (les deux serveurs)
     try {
       Logger.info('üîÑ Red√©marrage des serveurs lors du rollback...');
       await Promise.all([
         this.srv1Ptero.setPowerState('start').catch(error => {
           Logger.warning('‚ö†Ô∏è Impossible de red√©marrer srv1', error);
         }),
         this.srv2Ptero.setPowerState('start').catch(error => {
           Logger.warning('‚ö†Ô∏è Impossible de red√©marrer srv2', error);
         })
       ]);
       Logger.success('‚úÖ Serveurs red√©marr√©s lors du rollback');
     } catch (rollbackError) {
       Logger.error('‚ùå Erreur lors du red√©marrage des serveurs', rollbackError);
     }

     // 5. Nettoyer les fichiers temporaires syst√®me
     const systemTempDir = process.env.TEMP_CACHE_PATH || '/tmp';
     try {
       const tempFiles = await fs.readdir(systemTempDir);
       const transferFiles = tempFiles.filter(file => file.startsWith('transfer_'));
       
       for (const file of transferFiles) {
         try {
           const filePath = path.join(systemTempDir, file);
           const stats = await fs.stat(filePath);
           const ageInMinutes = (Date.now() - stats.mtime.getTime()) / (1000 * 60);
           
           // Supprimer les fichiers de transfert de plus de 5 minutes
           if (ageInMinutes > 5) {
             await fs.remove(filePath);
             Logger.success(`‚úÖ Fichier temporaire supprim√©: ${file}`);
           }
         } catch (fileError) {
           Logger.warning(`‚ö†Ô∏è Impossible de supprimer le fichier temporaire ${file}`, fileError);
         }
       }
     } catch (tempCleanupError) {
       Logger.warning('‚ö†Ô∏è Erreur lors du nettoyage des fichiers temporaires syst√®me', tempCleanupError);
     }

     Logger.success('‚úÖ Rollback complet v3.2 termin√©');

   } catch (error) {
     Logger.error('‚ùå Erreur critique lors du rollback v3.2', error);
   }
 }

 private async cleanup(srv1Connected: boolean, srv2Connected: boolean): Promise<void> {
   try {
     Logger.info('üîÑ Nettoyage des connexions v3.2...');
     
     if (srv1Connected) {
       try {
         await this.srv1Sftp.disconnect();
         Logger.success('‚úÖ Connexion SFTP srv1 ferm√©e');
       } catch (error) {
         Logger.warning('‚ö†Ô∏è Erreur lors de la fermeture SFTP srv1', error);
       }
     }
     
     if (srv2Connected) {
       try {
         await this.srv2Sftp.disconnect();
         Logger.success('‚úÖ Connexion SFTP srv2 ferm√©e');
       } catch (error) {
         Logger.warning('‚ö†Ô∏è Erreur lors de la fermeture SFTP srv2', error);
       }
     }
     
     Logger.success('‚úÖ Nettoyage v3.2 termin√©');
   } catch (error) {
     Logger.error('‚ùå Erreur lors du nettoyage v3.2', error);
   }
 }

 getTracker(): ProgressTracker {
   return this.tracker;
 }

 getCurrentArchiveName(): string {
   return this.archiveName;
 }

 getTempCachePath(): string {
   return this.tempCachePath;
 }
}